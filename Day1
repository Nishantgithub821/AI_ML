DAY 1 OF Code [ HOW WE PERFORM BASIC THINGS ON GOOGLE COLLAB AND ALSO HOW WE INITLIALIZE ARRAY AND USE IT ]


#First import numpy lib this is the first step very first 
import numpy as np
# let do addition,sub,mult,division onn two vectors okey
leta = np.array([1,2,3])   # always use np. to create an array or create an matrix okey 
letb = np.array([5,6,7])
print(leta+letb)
print(leta-letb)
print(leta*letb)
print(leta/letb)

#now we see product or of a scaler to a vector okey let scaler = 3
print(3*leta)
a = 3  # we also assign the value to variable and then multiply with any vector 
print(a*letb) # this way is not a scaler but for understanding that we also do this in this way
print(44*letb-33*leta)

#now wee check the length of the vector remember the underroot formula of length but here just comand 
# ALWAYS REMEMBER THIS COMMAND AND THIS IS THE FIRST COMMAND WHICH WE NOTE DOWN ON NOTEBOOK 
print(np.linalg.norm(leta))
print(np.linalg.norm(letb)) # this way we check the lenght now,

# now wee see the dot product okey
a = np.array([1,2])
b = np.array([-1,1])
#print(np.dot(dota,dotb))  # We directly write np.dot it understanad that we want to try the dot product 
c = np.dot(a,b)
print(c)

# now similar we do these all operations in three matrix also
#but dot product always happens in only two matrixes
d = np.array([[1,2,3,], [4,5,6],[7,8,9]])
print(d)
e = np.array([[0,0,8],[1,2,3],[2,3,4]])
print(e)
print(d+e)
print(d-e)
#SECOND COMMAND OF WRITE DOWN ON NOTEBOOK THAT FOR INVERSE 
f =  np.linalg.inv(e) #  if we write d in the place of e it gives error because inverse of det 0 is not exists
print(f)

OUR FIRST TOPIC IS ABOUT LINEAR COMBINATIONS IN LINEAR ALGEBRA OKEY 
#Linear combination
#1 First we wee the vector adition with apha and beta
# now in vector addition we mulitply the vector with alpha and beta
# and we also give the value maybe not so
a = np.array([1,2,3])
b = np.array([2,3,4])
alpha = 3
beta = 5

print(alpha*a+beta*b)

# Linear Combination Interpretation

# Imagine you have 3 LEGO blocks (v1, v2, v3)
# Each  block has a fixed shape and direction
# You are asked to build an exact  model (target vector t)

# You are allowed to use:
# some amount of block v1
# some amount of block v2
# some amount of block v3

# Question:
# Can I combine these blocks to build the exact target model?

# Mathematically:
# alpha1*v1 + alpha2*v2 + alpha3*v3 = t

# If this is possible → exact solution exists
# If blocks are dependent (det = 0) → blocks are useless together (singular matrix)

# Here, numpy finds:
# how much of each block (alpha1, alpha2, alpha3) we need
#code:

import numpy as np

# Define 3 vectors (building blocks)
v1 = np.array([1, 2, 1])
v2 = np.array([1, 1, 0])
v3 = np.array([0, 1, -1])

# Target vector (what we want to build)
t = np.array([1, 6, -5])

# Create matrix A using vectors as columns
A = np.column_stack([v1, v2, v3])    # THIRD COMMAND TO WRITE DOWN ON NOTEBOOK 

# Solve: A * alpha = t
# This finds alpha1, alpha2, alpha3
solution = np.linalg.solve(A, t)   #4th COMMAND TO WRITE DOWN ON NOTEBOOK [BECAUSE SOLVE DIRECTLY SOLVE THE EQ]

print("Coefficients (alpha1, alpha2, alpha3):", solution)

